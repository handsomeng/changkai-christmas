<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æ•å¼€é…’é¦† - åœ£è¯æ‰‹åŠ¿äº’åŠ¨</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Noto+Serif+SC:wght@700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000500; /* ææ·±ç»¿è‰²èƒŒæ™¯ */
            font-family: 'Noto Serif SC', serif;
            color: #eecfa1;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* æ‘„åƒå¤´ç”»é¢ (ç”¨äºè°ƒè¯•ï¼Œé»˜è®¤éšè—æˆ–å°çª—æ˜¾ç¤º) */
        #video-input {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            border: 2px solid #D4AF37;
            z-index: 10;
            transform: scaleX(-1); /* é•œåƒ */
            opacity: 0.7;
            display: none; /* é»˜è®¤éšè— */
        }

        /* UI å±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 40px;
            box-sizing: border-box;
        }

        .header {
            text-align: center;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
            /* ç§»é™¤äº†çŠ¶æ€æ ï¼Œä»…ä¿ç•™å¤´éƒ¨å¸ƒå±€å ä½ */
            margin-top: 20px;
        }

        h1 {
            font-family: 'Dancing Script', cursive;
            font-size: 3rem;
            color: #D4AF37;
            margin: 0;
            letter-spacing: 2px;
        }

        /* åº•éƒ¨æ§åˆ¶åŒºï¼šæ”¹ä¸ºæŒ‰é’® */
        #controls {
            pointer-events: auto;
            position: fixed;
            bottom: 40px;
            left: 40px;
        }

        .main-btn {
            background: linear-gradient(135deg, #D4AF37, #AA8822);
            color: #0f3b1e;
            border: none;
            padding: 15px 35px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
            transition: all 0.3s;
            font-family: 'Noto Serif SC', serif;
            font-size: 1.2rem;
        }

        .main-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.8);
        }

        /* å¼¹çª—æ ·å¼ */
        #modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 50;
            justify-content: center;
            align-items: center;
        }

        #modal-overlay.active {
            display: flex;
        }

        #modal-content {
            background: rgba(0, 30, 15, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #D4AF37;
            backdrop-filter: blur(10px);
            width: 90%;
            max-width: 500px;
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.6);
        }

        #modal-content h2 {
            color: #D4AF37;
            font-family: 'Noto Serif SC', serif;
            text-align: center;
            margin-top: 0;
            margin-bottom: 30px;
            font-size: 1.8rem;
        }

        .modal-input {
            width: 100%;
            background: transparent;
            border: none;
            border-bottom: 2px solid #D4AF37;
            color: #fff;
            font-family: 'Noto Serif SC', serif;
            font-size: 1.1rem;
            padding: 10px 5px;
            margin-bottom: 20px;
            outline: none;
            box-sizing: border-box;
        }

        .modal-input::placeholder {
            color: rgba(212, 175, 55, 0.5);
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        .modal-btn {
            flex: 1;
            background: linear-gradient(135deg, #D4AF37, #AA8822);
            color: #0f3b1e;
            border: none;
            padding: 12px 20px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
            transition: transform 0.2s;
            font-family: 'Noto Serif SC', serif;
            font-size: 1.1rem;
        }

        .modal-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }

        .modal-btn.cancel {
            background: linear-gradient(135deg, #666, #444);
        }

        /* å¤§å±é«˜äº®æ˜¾ç¤º */
        #highlight-display {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 60;
            text-align: center;
            pointer-events: none;
            width: 90%;
            max-width: 1200px;
            padding: 20px;
        }

        #highlight-display.active {
            display: block;
            animation: highlightFadeIn 0.5s ease-out;
        }

        @keyframes highlightFadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .highlight-blessing {
            font-family: 'Noto Serif SC', serif;
            font-size: 8rem;
            color: #FFD700;
            text-shadow: 0 0 50px rgba(255, 215, 0, 1),
                         0 0 100px rgba(255, 215, 0, 0.8),
                         0 0 150px rgba(255, 215, 0, 0.6);
            font-weight: bold;
            margin-bottom: 30px;
            line-height: 1.2;
            word-wrap: break-word;
            word-break: break-word;
        }

        .highlight-name {
            font-family: 'Noto Serif SC', serif;
            font-size: 3.5rem;
            color: #D4AF37;
            text-shadow: 0 0 30px rgba(212, 175, 55, 1),
                         0 0 60px rgba(212, 175, 55, 0.8);
            font-weight: bold;
            opacity: 0.9;
        }

        /* å“åº”å¼é€‚é… */
        @media (max-width: 768px) {
            .highlight-blessing {
                font-size: 4rem;
                padding: 0 20px;
            }
            .highlight-name {
                font-size: 2rem;
            }
        }

        @media (max-width: 480px) {
            .highlight-blessing {
                font-size: 3rem;
                padding: 0 20px;
            }
            .highlight-name {
                font-size: 1.5rem;
            }
        }

        .guide-panel {
            position: absolute;
            bottom: 20px;
            right: 200px;
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-right: 2px solid #D4AF37;
            color: #ccc;
            font-size: 0.85rem;
            line-height: 1.8;
            backdrop-filter: blur(4px);
            text-align: right;
        }
        
        .guide-item {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin-bottom: 8px;
        }
        
        .icon {
            margin-left: 10px;
            color: #D4AF37;
            font-weight: bold;
        }
        
        /* äºŒç»´ç åŒºåŸŸ */
        .qrcode-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.5);
            text-align: center;
            z-index: 20;
            pointer-events: auto;
        }

        .qrcode-title {
            font-family: 'Noto Serif SC', serif;
            color: #0f3b1e;
            font-size: 0.9rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #qrcode {
            display: inline-block;
            padding: 5px;
            background: white;
        }

        .qrcode-hint {
            font-size: 0.75rem;
            color: #666;
            margin-top: 8px;
        }

        .camera-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: rgba(0, 20, 10, 0.8);
            border-radius: 50%;
            border: 2px solid #D4AF37;
            color: #D4AF37;
            font-size: 2rem;
            backdrop-filter: blur(5px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
            z-index: 20;
            pointer-events: auto;
        }

        .camera-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.6);
            background: rgba(0, 30, 15, 0.9);
        }

        .camera-btn.active {
            color: #00ff00;
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }

        .camera-btn.error {
            border-color: #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
        }

        .camera-btn.connecting {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
            }
            50% {
                box-shadow: 0 0 30px rgba(212, 175, 55, 0.8);
            }
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #D4AF37;
            flex-direction: column;
            transition: opacity 1s;
        }
        
        /* 3D Cursor follower */
        #cursor-follower {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 0, 0, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 20;
            display: none; /* Initially hidden until hand detected */
            box-shadow: 0 0 10px red;
        }

    </style>
    
    <!-- Libraries -->
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Post Processing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <!-- Tweening -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    
    <!-- QRCode -->
    <script src="https://unpkg.com/qrcodejs@1.0.0/qrcode.min.js"></script>
    
    <!-- Supabase -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="./config.js"></script>

</head>
<body>

    <div id="loading">
        <h1>Loading Magic...</h1>
        <p>åˆå§‹åŒ–è§†è§‰å¼•æ“ä¸AIæ¨¡å‹</p>
    </div>

    <div id="canvas-container"></div>
    <video id="video-input" playsinline></video>
    <div id="cursor-follower"></div>

    <div id="ui-layer">
        <div class="header">
            <!-- ä»…ä¿ç•™æ ‡é¢˜ï¼ŒçŠ¶æ€æ å·²ç§»é™¤ -->
        </div>

        <!-- äºŒç»´ç  -->
        <div class="qrcode-container">
            <div class="qrcode-title">ğŸ“± æ‰«ç é€ç¥ç¦</div>
            <div id="qrcode"></div>
            <div class="qrcode-hint">ç¥ç¦å°†å®æ—¶æ˜¾ç¤º</div>
        </div>

        <button class="camera-btn" id="camera-btn" onclick="toggleCamera()" title="ç‚¹å‡»å¯åŠ¨æ‘„åƒå¤´">
            ğŸ“·
        </button>

        <div class="guide-panel">
            <div class="guide-item">æ¡æ‹³ï¼šåˆæ‹¢æˆåœ£è¯æ ‘ <span class="icon">âœŠ</span></div>
            <div class="guide-item">å¼ å¼€ï¼šæ•£å¼€æˆæ˜Ÿäº‘ <span class="icon">ğŸ–</span></div>
            <div class="guide-item">ç§»åŠ¨ï¼šæ—‹è½¬è§†è§’ <span class="icon">ğŸ‘‹</span></div>
            <div class="guide-item" style="margin-top: 15px; font-size: 0.75rem; opacity: 0.7;">
                æ— æ‘„åƒå¤´æ—¶è‡ªåŠ¨æ—‹è½¬
            </div>
        </div>

        <div id="controls">
            <button class="main-btn" onclick="openModal()">ç•™ä¸‹ç¥ç¦</button>
        </div>
    </div>

    <!-- å¼¹çª— -->
    <div id="modal-overlay" onclick="closeModalOnOverlay(event)">
        <div id="modal-content">
            <h2>âœ¨ ç•™ä¸‹ä½ çš„åœ£è¯ç¥ç¦ âœ¨</h2>
            <input type="text" id="modal-name-input" class="modal-input" placeholder="ä½ çš„åå­—ï¼ˆé€‰å¡«ï¼‰" maxlength="10">
            <input type="text" id="modal-blessing-input" class="modal-input" placeholder="å†™ä¸‹ä½ çš„ç¥ç¦..." maxlength="30">
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="closeModal()">å–æ¶ˆ</button>
                <button class="modal-btn" onclick="submitBlessing()">å‘é€</button>
            </div>
        </div>
    </div>

    <!-- å¤§å±é«˜äº®æ˜¾ç¤º -->
    <div id="highlight-display">
        <div class="highlight-blessing" id="highlight-blessing"></div>
        <div class="highlight-name" id="highlight-name"></div>
    </div>
    
    <div style="display:none;">
        <!-- å ä½ï¼Œç”¨äºé—­åˆä¹‹å‰çš„div -->
    </div>
    
    <div id="ui-layer-backup" style="display:none;">
        <!-- åŸæ¥è¢«æ›¿æ¢çš„ç»“æŸæ ‡ç­¾çš„å ä½ -->
    </div>

    <script>
        // --- 1. é…ç½®ä¸å…¨å±€å˜é‡ ---
        const CONFIG = {
            colors: {
                matteGreen: 0x0f3b1e,
                metalGold: 0xffd700,
                christmasRed: 0xaa0000,
                bg: 0x000500
            },
            particleCount: 800,
            treeHeight: 25,
            treeRadius: 10
        };

        const STATE = {
            TREE: 'tree',
            SCATTER: 'scatter'
        };

        let currentState = STATE.TREE;
        let targetState = STATE.TREE;
        
        let scene, camera, renderer, composer;
        let clock = new THREE.Clock();
        let particles = []; // å­˜å‚¨æ‰€æœ‰åŠ¨æ€å¯¹è±¡ { mesh, treePos, scatterPos, velocity }
        let sceneGroup; // åŒ…å«æ‰€æœ‰ç²’å­çš„ç»„ï¼Œç”¨äºæ•´ä½“æ—‹è½¬
        let danmakuGroup; // åŒ…å«å¼¹å¹•çš„ç»„ï¼Œç‹¬ç«‹äº sceneGroupï¼Œä¸éšæ‰‹åŠ¿å¤§å¹…æ—‹è½¬
        
        // Hand Tracking State
        let handPosition = { x: 0, y: 0 };
        let isHandDetected = false;

        // Danmaku System
        let danmakuList = [
            "åœ£è¯å¿«ä¹ï¼",
            "æˆ‘çš„ç¤¼ç‰©å‘¢ï¼",
            "æ•å¼€é…’é¦†æˆ‘å¤ªçˆ±äº†ï¼",
            "æ•å¼€ä¸‡å²ï¼",
            "æ˜å¹´ä¸€å®šè¦å¹¸ç¦ï¼",
            "ä¸‡äº‹å¦‚æ„",
            "æˆ‘å–œæ¬¢è¿™å„¿çš„ç²¾é…¿",
            "å¥½å–å¥½ç©",
            "æœ‰è¶£æœ‰æ–™",
            "ä»Šå¹´æ²¡äººé€æˆ‘è‹¹æœï¼Œæ˜å¹´ä¸€å®šæœ‰",
            "æ•å¼€çš„ç²¾é…¿æ²»æ„ˆäº†æˆ‘",
            "åœ¨æ•å¼€é‡è§æœ€å¥½çš„è‡ªå·±",
            "åœ£è¯å¤œæ¥æ•å¼€å°é…Œä¸€æ¯",
            "æ•å¼€çš„æ°›å›´å¤ªæ£’äº†",
            "æ¯ä¸€æ¯éƒ½æ˜¯ç”¨å¿ƒä¹‹ä½œ",
            "åœ£è¯æ ‘ä¸‹çš„æ¸©æš–æ—¶å…‰",
            "æ•å¼€è®©æˆ‘æ‰¾åˆ°äº†å½’å±æ„Ÿ",
            "ç²¾é…¿é…åœ£è¯ï¼Œå®Œç¾ï¼",
            "è¿™é‡Œçš„æ¯ä¸ªäººéƒ½å¾ˆæœ‰è¶£",
            "æ•å¼€æ˜¯æˆ‘çš„ç²¾ç¥è§’è½",
            "åœ£è¯èŠ‚æœ€æƒ³å¾…çš„åœ°æ–¹",
            "æ•å¼€çš„è€æ¿å¥½å¸…å•Š",
            "æ¥æ•å¼€å°±å¯¹äº†",
            "ç²¾é…¿çˆ±å¥½è€…çš„å¤©å ‚",
            "åœ£è¯é™å®šé…’å¤ªå¥½å–äº†",
            "åœ¨è¿™é‡Œåº¦è¿‡æœ€ç¾åœ£è¯",
            "æ•å¼€çš„æ•…äº‹æ°¸è¿œå¬ä¸è…»",
            "æ¯æ¬¡æ¥éƒ½æœ‰æ–°å‘ç°",
            "åœ£è¯å¿«ä¹ï¼å¹²æ¯ï¼",
            "æ•å¼€è®©å†¬å¤©å˜å¾—æ¸©æš–",
            "è¿™é‡Œçš„éŸ³ä¹å’Œé…’éƒ½åˆšåˆšå¥½",
            "åœ£è¯å¤œçš„æµªæ¼«å›å¿†",
            "æ•å¼€æ˜¯æˆ‘çš„è§£å‹åœ£åœ°",
            "ç²¾é…¿ç•Œçš„å®è—å°åº—",
            "åœ£è¯ç¤¼ç‰©å°±è¦æ•å¼€å•¤é…’",
            "åœ¨æ•å¼€æ‰¾åˆ°äº†çŸ¥éŸ³",
            "æ¯ä¸€å£éƒ½æ˜¯å¹¸ç¦çš„å‘³é“",
            "åœ£è¯èŠ‚æ¥æ•å¼€è®¸æ„¿",
            "æ•å¼€çš„åœ£è¯æ°›å›´å¤ªèµäº†",
            "è¿™é‡Œæ˜¯çµé­‚çš„æ –æ¯åœ°",
            "ç²¾é…¿+åœ£è¯=å¿«ä¹",
            "æ•å¼€é™ªæˆ‘è¿‡æ¯ä¸ªèŠ‚æ—¥",
            "åœ£è¯è€äººå¿«æ¥æ•å¼€",
            "åœ¨è¿™é‡Œæ„Ÿå—ç”Ÿæ´»çš„ç¾å¥½",
            "æ•å¼€çš„æ¯ä¸€å¤©éƒ½æ˜¯èŠ‚æ—¥",
            "ç²¾é…¿è®©åœ£è¯æ›´æœ‰ä»ªå¼æ„Ÿ",
            "æ•å¼€æ˜¯æˆ‘çš„ç¬¬äºŒä¸ªå®¶",
            "åœ£è¯å¤œå¹²æ¯åˆ°å¤©äº®",
            "åœ¨æ•å¼€æ”¶è·æ»¡æ»¡æƒŠå–œ",
            "ç²¾é…¿é…çŸ¥å·±ï¼Œåœ£è¯æ›´ç¾ä¸½"
        ];
        let activeDanmakuObjects = [];
        let lastSpawnTime = 0;

        // --- 2. åˆå§‹åŒ– Three.js åœºæ™¯ ---
        function initScene() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 40;
            camera.position.y = 10;
            camera.lookAt(0, 10, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // åŒ…å«æ‰€æœ‰ç²’å­/æ ‘çš„å®¹å™¨
            sceneGroup = new THREE.Group();
            scene.add(sceneGroup);

            // åŒ…å«å¼¹å¹•çš„å®¹å™¨ (æ”¾åœ¨èƒŒæ™¯)
            danmakuGroup = new THREE.Group();
            danmakuGroup.position.z = -15; // æ”¾åœ¨æ ‘çš„åé¢
            scene.add(danmakuGroup);

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(CONFIG.colors.metalGold, 1.5, 100);
            pointLight.position.set(10, 20, 10);
            scene.add(pointLight);
            
            const redLight = new THREE.PointLight(CONFIG.colors.christmasRed, 1.0, 80);
            redLight.position.set(-10, 5, 10);
            scene.add(redLight);

            // åå¤„ç† (Bloom è¾‰å…‰)
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.2; // è¾‰å…‰å¼ºåº¦
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // ç›‘å¬çª—å£å¤§å°
            window.addEventListener('resize', onWindowResize, false);
            
            // åˆå§‹åŒ–å†…å®¹
            createParticles();
            createTopText();
        }

        // --- 3. åˆ›å»ºå†…å®¹ (ç²’å­ä¸å½¢çŠ¶) ---
        function createParticles() {
            // 3.1 å‡ ä½•ä½“ä¸æè´¨
            const sphereGeo = new THREE.SphereGeometry(0.4, 16, 16);
            const cubeGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            
            const goldMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.metalGold, 
                metalness: 0.9, 
                roughness: 0.1,
                emissive: 0x332200 
            });
            
            const redMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.christmasRed, 
                metalness: 0.5, 
                roughness: 0.2,
                emissive: 0x220000
            });
            
            const greenMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.matteGreen, 
                metalness: 0.0, 
                roughness: 0.9 
            });

            // 3.2 ç”Ÿæˆé€»è¾‘ä½ç½®
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const p = {
                    mesh: null,
                    treePos: new THREE.Vector3(),
                    scatterPos: new THREE.Vector3(),
                    velocity: new THREE.Vector3((Math.random()-0.5)*0.05, (Math.random()-0.5)*0.05, (Math.random()-0.5)*0.05),
                };

                // --- Tree Form Calculation (Spiral Cone) ---
                const t = i / CONFIG.particleCount; // 0 to 1
                const angle = t * Math.PI * 20; // 10 circles
                const radius = CONFIG.treeRadius * (1 - t);
                const y = t * CONFIG.treeHeight;
                p.treePos.set(
                    Math.cos(angle) * radius,
                    y - CONFIG.treeHeight / 2 + 5, // Center Y slightly
                    Math.sin(angle) * radius
                );
                
                // Add some jitter to tree pos for volume
                p.treePos.x += (Math.random() - 0.5);
                p.treePos.z += (Math.random() - 0.5);
                p.treePos.y += (Math.random() - 0.5);

                // --- Scatter Form Calculation (Random Cloud) ---
                const rScatter = 25;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                p.scatterPos.set(
                    rScatter * Math.sin(phi) * Math.cos(theta),
                    rScatter * Math.sin(phi) * Math.sin(theta),
                    rScatter * Math.cos(phi)
                );

                // --- Mesh Creation (All Ornaments now, no photos) ---
                let mesh;
                const rand = Math.random();
                if (rand < 0.33) {
                    mesh = new THREE.Mesh(sphereGeo, goldMat);
                } else if (rand < 0.66) {
                    mesh = new THREE.Mesh(sphereGeo, redMat);
                } else {
                    mesh = new THREE.Mesh(cubeGeo, greenMat);
                }
                mesh.position.copy(p.treePos);
                // Random scale
                const s = 0.5 + Math.random() * 0.8;
                mesh.scale.set(s, s, s);
                sceneGroup.add(mesh);
                p.mesh = mesh;
                
                particles.push(p);
            }
        }

        // --- 4. é¡¶éƒ¨æ–‡å­— (Canvas Texture) ---
        function createTopText() {
            // åŠ è½½ Logo
            const textureLoader = new THREE.TextureLoader();
            const logoPath = './æ•å¼€logo.jpg';
            textureLoader.load(logoPath, (logoTexture) => {
                logoTexture.minFilter = THREE.LinearFilter;
                logoTexture.magFilter = THREE.LinearFilter;
                const logoMaterial = new THREE.SpriteMaterial({ map: logoTexture, transparent: true });
                const logoSprite = new THREE.Sprite(logoMaterial);
                logoSprite.scale.set(6, 6, 1);
                // Logo ä½ç½®ï¼šåœ¨æ–‡å­—å·¦è¾¹ï¼Œå›ºå®šä¸æ—‹è½¬
                logoSprite.position.set(-12, CONFIG.treeHeight / 2 + 15, 0);
                scene.add(logoSprite);
                console.log("Logo loaded successfully");
            }, undefined, (err) => {
                console.error("Logo loading failed:", err);
                // å°è¯•å…¶ä»–è·¯å¾„
                textureLoader.load('æ•å¼€logo.jpg', (logoTexture) => {
                    logoTexture.minFilter = THREE.LinearFilter;
                    logoTexture.magFilter = THREE.LinearFilter;
                    const logoMaterial = new THREE.SpriteMaterial({ map: logoTexture, transparent: true });
                    const logoSprite = new THREE.Sprite(logoMaterial);
                    logoSprite.scale.set(6, 6, 1);
                    logoSprite.position.set(-12, CONFIG.treeHeight / 2 + 15, 0);
                    scene.add(logoSprite);
                    console.log("Logo loaded with alternative path");
                });
            });

            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');

            // ç»˜åˆ¶ "æ•å¼€é…’é¦†"
            ctx.fillStyle = 'rgba(0,0,0,0)'; // Transparent
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // å»é™¤æ¨¡ç³Šçš„é˜´å½±æ•ˆæœ
            // ctx.shadowColor = "#D4AF37";
            // ctx.shadowBlur = 20;
            
            ctx.font = 'bold 240px "Noto Serif SC", serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#D4AF37';
            ctx.fillText("æ•å¼€é…’é¦†", canvas.width / 2, 400);

            // ç»˜åˆ¶ "Merry Christmas"
            ctx.font = 'italic 200px "Dancing Script", cursive';
            ctx.fillStyle = '#FFD700'; // Lighter gold
            ctx.fillText("Merry Christmas", canvas.width / 2, 700);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            
            sprite.scale.set(25, 12.5, 1);
            // æ ‡é¢˜ä½ç½®è°ƒé«˜ï¼Œå›ºå®šä¸æ—‹è½¬
            sprite.position.set(0, CONFIG.treeHeight / 2 + 15, 0);
            scene.add(sprite);
            
            // Add a Star on top
            const starGeo = new THREE.OctahedronGeometry(1.5, 0);
            const starMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffaa, 
                emissive: 0xffdd00,
                emissiveIntensity: 2
            });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, CONFIG.treeHeight / 2 + 5, 0);
            
            // Star animation loop
            const animateStar = () => {
                star.rotation.y += 0.02;
                requestAnimationFrame(animateStar);
            }
            animateStar();
            
            sceneGroup.add(star);
        }

        // --- 5. å¼¹å¹•é€»è¾‘ ---
        
        // åˆ›å»ºå•ä¸ªå¼¹å¹•å¯¹è±¡
        function spawnDanmaku(text, name = '') {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            ctx.font = 'bold 100px "Noto Serif SC", serif';
            ctx.fillStyle = '#FFD700';
            ctx.textAlign = 'center';
            
            // å¦‚æœæœ‰åå­—ï¼Œæ˜¾ç¤ºæ ¼å¼ä¸º "åå­—: ç¥ç¦å†…å®¹"
            const displayText = name ? `${name}: ${text}` : text;
            ctx.fillText(displayText, canvas.width/2, 150);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0.9 });
            const sprite = new THREE.Sprite(material);
            
            // éšæœºé«˜åº¦ (-5 åˆ° 20)
            const y = (Math.random() * 25) - 5;
            // åˆå§‹ X (å±å¹•å³ä¾§å¤–)
            const x = 50 + Math.random() * 20;
            // æ·±åº¦ Z (æ ‘çš„åé¢)
            const z = (Math.random() * 10) - 5; // local z inside danmakuGroup

            // ç¼©å°å¼¹å¹•å®½åº¦ï¼Œä»18æ”¹ä¸º12
            sprite.scale.set(12, 4.5, 1);
            sprite.position.set(x, y, z);
            
            danmakuGroup.add(sprite);
            
            activeDanmakuObjects.push({
                mesh: sprite,
                speed: 0.1 + Math.random() * 0.1
            });
        }

        // å¼¹çª—æ§åˆ¶
        window.openModal = function() {
            document.getElementById('modal-overlay').classList.add('active');
        }
        
        window.closeModal = function() {
            document.getElementById('modal-overlay').classList.remove('active');
            document.getElementById('modal-name-input').value = '';
            document.getElementById('modal-blessing-input').value = '';
        }
        
        window.closeModalOnOverlay = function(event) {
            if (event.target.id === 'modal-overlay') {
                closeModal();
            }
        }
        
        // æäº¤ç¥ç¦
        window.submitBlessing = function() {
            const nameInput = document.getElementById('modal-name-input');
            const blessingInput = document.getElementById('modal-blessing-input');
            const name = nameInput.value.trim();
            const text = blessingInput.value.trim();
            
            if (!text) {
                alert('è¯·è¾“å…¥ç¥ç¦å†…å®¹');
                return;
            }
            
            // å…³é—­å¼¹çª—
            closeModal();
            
            // æ˜¾ç¤ºå¤§å±é«˜äº®
            showHighlight(name, text);
            
            // 5ç§’åæ·»åŠ åˆ°å¼¹å¹•
            setTimeout(() => {
                const fullText = name ? `${name}: ${text}` : text;
                danmakuList.push(fullText);
                spawnDanmaku(text, name);
            }, 5000);
        }
        
        // æ˜¾ç¤ºå¤§å±é«˜äº®
        function showHighlight(name, blessing) {
            const highlightDiv = document.getElementById('highlight-display');
            const nameDiv = document.getElementById('highlight-name');
            const blessingDiv = document.getElementById('highlight-blessing');
            
            blessingDiv.textContent = blessing;
            
            if (name) {
                nameDiv.textContent = 'â€”â€” ' + name;
                nameDiv.style.display = 'block';
            } else {
                nameDiv.style.display = 'none';
            }
            
            highlightDiv.classList.add('active');
            
            // 5ç§’åéšè—
            setTimeout(() => {
                highlightDiv.classList.remove('active');
            }, 5000);
        }
        
        // é”®ç›˜å›è½¦å‘é€
        setTimeout(() => {
            const blessingInput = document.getElementById('modal-blessing-input');
            const nameInput = document.getElementById('modal-name-input');
            if (blessingInput) {
                blessingInput.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') submitBlessing();
                });
            }
            if (nameInput) {
                nameInput.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        blessingInput.focus();
                    }
                });
            }
        }, 100);

        // å¾ªç¯ç”Ÿæˆå’Œç§»åŠ¨
        function updateDanmaku() {
            const now = clock.getElapsedTime();
            
            // è‡ªåŠ¨ç”Ÿæˆ (æ¯2ç§’ç”Ÿæˆä¸€ä¸ªå¾ªç¯å†…å®¹)
            if (now - lastSpawnTime > 2) {
                const text = danmakuList[Math.floor(Math.random() * danmakuList.length)];
                spawnDanmaku(text);
                lastSpawnTime = now;
            }
            
            // ç§»åŠ¨ç°æœ‰å¼¹å¹•
            for (let i = activeDanmakuObjects.length - 1; i >= 0; i--) {
                const obj = activeDanmakuObjects[i];
                obj.mesh.position.x -= obj.speed;
                
                // å¦‚æœç§»å‡ºå·¦è¾¹ç•Œï¼Œé”€æ¯
                if (obj.mesh.position.x < -50) {
                    danmakuGroup.remove(obj.mesh);
                    obj.mesh.material.map.dispose();
                    obj.mesh.material.dispose();
                    activeDanmakuObjects.splice(i, 1);
                }
            }
        }

        // --- 6. æ ¸å¿ƒåŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            
            // çŠ¶æ€æ’å€¼é€»è¾‘
            particles.forEach((p, idx) => {
                let targetPos;

                if (currentState === STATE.TREE) {
                    targetPos = p.treePos;
                } else if (currentState === STATE.SCATTER) {
                    targetPos = p.scatterPos;
                }

                // 1. ç§»åŠ¨ä½ç½® (Lerp)
                const lerpSpeed = 2.0 * dt;
                p.mesh.position.lerp(targetPos, lerpSpeed);
                
                // æ•£å¼€çŠ¶æ€ä¸‹å¢åŠ ä¸€ç‚¹æ¼‚æµ®æ„Ÿ
                if (currentState === STATE.SCATTER) {
                     p.mesh.position.x += Math.sin(clock.elapsedTime + idx) * 0.01;
                     p.mesh.position.y += Math.cos(clock.elapsedTime + idx) * 0.01;
                }
            });

            // åœºæ™¯æ—‹è½¬ (æ‰‹åŠ¿æ§åˆ¶)
            if (isHandDetected) {
                // Map handPosition.x (0 to 1) to rotation angle
                const targetRotY = (handPosition.x - 0.5) * 4; // -2 to 2 rads
                const targetRotX = (handPosition.y - 0.5) * 2;
                
                sceneGroup.rotation.y += (targetRotY - sceneGroup.rotation.y) * 0.05;
                sceneGroup.rotation.x += (targetRotX - sceneGroup.rotation.x) * 0.05;
            } else {
                // è‡ªåŠ¨ç¼“æ…¢æ—‹è½¬
                sceneGroup.rotation.y += 0.005;
                // æ…¢æ…¢å¤ä½ X è½´
                sceneGroup.rotation.x += (0 - sceneGroup.rotation.x) * 0.05;
            }
            
            // æ›´æ–°å¼¹å¹•
            updateDanmaku();

            composer.render();
            TWEEN.update();
        }

        // --- 7. MediaPipe Hands é›†æˆ ---
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. æ›´æ–°æ‰‹æŒä¸­å¿ƒ (ç”¨äºæ—‹è½¬)
                const cx = 1 - (landmarks[0].x + landmarks[9].x) / 2; // Mirror x
                const cy = (landmarks[0].y + landmarks[9].y) / 2;
                
                handPosition.x = cx;
                handPosition.y = cy;
                
                // æ›´æ–° Cursor
                const cursor = document.getElementById('cursor-follower');
                cursor.style.display = 'block';
                cursor.style.left = (cx * 100) + '%';
                cursor.style.top = (cy * 100) + '%';

                // 2. çŠ¶æ€è¯†åˆ«é€»è¾‘
                
                // A. æ¡æ‹³æ£€æµ‹ (Fist)
                const wrist = landmarks[0];
                const tips = [8, 12, 16, 20];
                let avgDist = 0;
                tips.forEach(idx => {
                    const tip = landmarks[idx];
                    const d = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                    avgDist += d;
                });
                avgDist /= 4;
                
                const isFist = avgDist < 0.25;
                const isOpen = avgDist > 0.45;

                // --- çŠ¶æ€åˆ‡æ¢é€»è¾‘ ---
                if (isFist) {
                    if (targetState !== STATE.TREE) {
                        targetState = STATE.TREE;
                        currentState = STATE.TREE;
                    }
                } else if (isOpen) {
                    if (targetState !== STATE.SCATTER) {
                        targetState = STATE.SCATTER;
                        currentState = STATE.SCATTER;
                    }
                }
                
                cursor.style.borderColor = "red";

            } else {
                isHandDetected = false;
                document.getElementById('cursor-follower').style.display = 'none';
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 8. Supabase å®æ—¶ç¥ç¦ç³»ç»Ÿ ---
        
        // åˆå§‹åŒ– Supabase
        let supabaseClient;
        try {
            if (typeof supabase !== 'undefined' && typeof SUPABASE_CONFIG !== 'undefined') {
                const { createClient } = supabase;
                supabaseClient = createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey);
                console.log('âœ… Supabase initialized');
            } else {
                console.warn('âš ï¸ Supabase or config not loaded');
            }
        } catch (error) {
            console.error('Supabase initialization failed:', error);
        }
        
        // ç”ŸæˆäºŒç»´ç 
        function generateQRCode() {
            try {
                const qrcodeElement = document.getElementById('qrcode');
                
                // æ£€æŸ¥ QRCode åº“æ˜¯å¦åŠ è½½
                if (typeof QRCode === 'undefined') {
                    console.warn('QRCode library not loaded, retrying...');
                    qrcodeElement.innerHTML = '<p style="color:#D4AF37;font-size:0.8rem;padding:10px;">äºŒç»´ç åŠ è½½ä¸­...</p>';
                    
                    // 3ç§’åé‡è¯•
                    setTimeout(() => {
                        if (typeof QRCode !== 'undefined') {
                            generateQRCode();
                        } else {
                            console.error('QRCode library failed to load');
                            qrcodeElement.innerHTML = '<p style="color:#D4AF37;font-size:0.8rem;padding:10px;line-height:1.6;">ğŸ“± æ‰«ç é€ç¥ç¦<br><br>è¯·è®¿é—®:<br>' + window.location.origin + '/æ‰‹æœºç«¯ç¥ç¦.html</p>';
                        }
                    }, 3000);
                    return;
                }
                
                // æ¸…ç©ºä¹‹å‰çš„å†…å®¹
                qrcodeElement.innerHTML = '';
                
                // ç›´æ¥ä½¿ç”¨åŸŸå + æ‰‹æœºç«¯é¡µé¢è·¯å¾„
                const mobileUrl = window.location.origin + '/æ‰‹æœºç«¯ç¥ç¦.html';
                
                new QRCode(qrcodeElement, {
                    text: mobileUrl,
                    width: 120,
                    height: 120,
                    colorDark: '#0f3b1e',
                    colorLight: '#ffffff',
                    correctLevel: QRCode.CorrectLevel.L  // æ”¹ä¸º Lï¼ˆä½å®¹é”™ï¼‰ä»¥æ”¯æŒæ›´é•¿çš„ URL
                });
                
                console.log('âœ… QR Code generated for:', mobileUrl);
            } catch (error) {
                console.error('QR Code generation failed:', error);
                document.getElementById('qrcode').innerHTML = '<p style="color:#D4AF37;font-size:0.8rem;padding:10px;line-height:1.6;">ğŸ“± æ‰«ç é€ç¥ç¦<br><br>è¯·è®¿é—®:<br>' + window.location.origin + '/æ‰‹æœºç«¯ç¥ç¦.html</p>';
            }
        }
        
        // è®¢é˜…æ–°ç¥ç¦
        function subscribeToNewBlessings() {
            try {
                if (!supabaseClient) {
                    console.warn('Supabase client not initialized');
                    return;
                }
                
                supabaseClient
                    .channel('blessings_channel')
                    .on(
                        'postgres_changes',
                        {
                            event: 'INSERT',
                            schema: 'public',
                            table: 'blessings'
                        },
                        (payload) => {
                            console.log('New blessing received:', payload.new);
                            const { name, blessing } = payload.new;
                            
                            // æ˜¾ç¤ºå¤§å±é«˜äº®
                            showHighlight(name, blessing);
                            
                            // 5ç§’åæ·»åŠ åˆ°å¼¹å¹•åˆ—è¡¨
                            setTimeout(() => {
                                const fullText = name ? `${name}: ${blessing}` : blessing;
                                danmakuList.push(fullText);
                                // ç«‹å³ç”Ÿæˆä¸€ä¸ªå¼¹å¹•
                                spawnDanmaku(blessing, name);
                            }, 5000);
                        }
                    )
                    .subscribe((status) => {
                        if (status === 'SUBSCRIBED') {
                            console.log('âœ… Subscribed to blessings in real-time');
                        } else if (status === 'CHANNEL_ERROR') {
                            console.error('âŒ Subscription failed');
                        }
                    });
            } catch (error) {
                console.error('Subscription error:', error);
            }
        }
        
        // --- 9. å¯åŠ¨æµç¨‹ ---
        
        // åˆå§‹åŒ– 3D
        initScene();
        animate();
        
        // ç”ŸæˆäºŒç»´ç ï¼ˆå»¶è¿Ÿç¡®ä¿åº“å·²åŠ è½½ï¼‰
        setTimeout(() => {
            generateQRCode();
        }, 100);
        
        // è®¢é˜…å®æ—¶ç¥ç¦
        subscribeToNewBlessings();

        // éšè—åŠ è½½ç•Œé¢ï¼ˆå¢åŠ è¶…æ—¶ä¿æŠ¤ï¼‰
        const loading = document.getElementById('loading');
        function hideLoading() {
            if (loading && loading.style.display !== 'none') {
                loading.style.opacity = 0;
                setTimeout(() => {
                    if (loading) loading.style.display = 'none';
                }, 1000);
            }
        }
        
        // ç«‹å³éšè—åŠ è½½ç•Œé¢ï¼Œä¸ç­‰å¾…å…¶ä»–èµ„æº
        setTimeout(hideLoading, 1000);
        
        // è¶…æ—¶ä¿æŠ¤ï¼šå¦‚æœ 5 ç§’åè¿˜æ²¡éšè—ï¼Œå¼ºåˆ¶éšè—
        setTimeout(hideLoading, 5000);

        // æ‘„åƒå¤´ç›¸å…³å˜é‡
        const videoElement = document.getElementById('video-input');
        let cameraInitialized = false;
        let cameraActive = false;
        let handsInstance = null;
        let cameraUtilsInstance = null;
        let isInitializing = false;

        // åœæ­¢æ‘„åƒå¤´
        function stopCamera() {
            try {
                if (videoElement && videoElement.srcObject) {
                    const tracks = videoElement.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    videoElement.srcObject = null;
                }
                videoElement.style.display = 'none';
                cameraActive = false;
                console.log("Camera stopped");
            } catch (err) {
                console.error("Error stopping camera:", err);
            }
        }

        // é‡ç½®æ‘„åƒå¤´çŠ¶æ€
        function resetCamera() {
            stopCamera();
            cameraInitialized = false;
            isInitializing = false;
            handsInstance = null;
            cameraUtilsInstance = null;
            
            const btn = document.getElementById('camera-btn');
            btn.classList.remove('connecting', 'active', 'error');
            btn.innerHTML = 'ğŸ“·';
            btn.title = 'ç‚¹å‡»å¯åŠ¨æ‘„åƒå¤´';
        }

        // åˆå§‹åŒ–æ‘„åƒå¤´
        async function initCamera() {
            // é˜²æ­¢é‡å¤åˆå§‹åŒ–
            if (isInitializing) {
                console.log("Already initializing...");
                return;
            }
            
            if (cameraInitialized && cameraActive) {
                console.log("Camera already active");
                return;
            }
            
            isInitializing = true;
            const btn = document.getElementById('camera-btn');
            btn.classList.add('connecting');
            btn.title = 'è¿æ¥ä¸­...è¯·ç¨å€™';
            btn.disabled = true;
            
            try {
                // æ¸…ç†ä¹‹å‰çš„å®ä¾‹
                if (handsInstance || cameraUtilsInstance) {
                    stopCamera();
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                handsInstance = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});
                
                handsInstance.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                handsInstance.onResults(onResults);
                
                cameraUtilsInstance = new Camera(videoElement, {
                    onFrame: async () => {
                        if (handsInstance && cameraActive) {
                            await handsInstance.send({image: videoElement});
                        }
                    },
                    width: 320,
                    height: 240
                });
                
                await cameraUtilsInstance.start();
                
                console.log("Camera started successfully");
                videoElement.style.display = 'block';
                cameraInitialized = true;
                cameraActive = true;
                isInitializing = false;
                
                btn.classList.remove('connecting', 'error');
                btn.classList.add('active');
                btn.innerHTML = 'âœ“';
                btn.title = 'æ‘„åƒå¤´å·²è¿æ¥ï¼ˆç‚¹å‡»å¯é‡ç½®ï¼‰';
                btn.disabled = false;
                
            } catch (err) {
                console.error("Camera initialization failed:", err);
                isInitializing = false;
                cameraInitialized = false;
                
                btn.classList.remove('connecting');
                btn.classList.add('error');
                btn.innerHTML = 'ğŸ“·';
                btn.title = 'è¿æ¥å¤±è´¥ï¼Œç‚¹å‡»é‡è¯•';
                btn.disabled = false;
                
                // æ›´å‹å¥½çš„é”™è¯¯æç¤º
                let errorMsg = 'æ— æ³•å¯åŠ¨æ‘„åƒå¤´\n\n';
                if (err.name === 'NotAllowedError') {
                    errorMsg += 'è¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸æ‘„åƒå¤´æƒé™\n';
                    errorMsg += 'Chrome: åœ°å€æ å·¦ä¾§ ğŸ”’ â†’ ç½‘ç«™è®¾ç½® â†’ æ‘„åƒå¤´';
                } else if (err.name === 'NotFoundError') {
                    errorMsg += 'æœªæ£€æµ‹åˆ°æ‘„åƒå¤´è®¾å¤‡\n';
                    errorMsg += 'Mac miniè¯·ç¡®ä¿å·²è¿æ¥ iPhone å¹¶å¼€å¯"è¿ç»­äº’é€šç›¸æœº"';
                } else {
                    errorMsg += 'é”™è¯¯: ' + err.message + '\n';
                    errorMsg += 'å»ºè®®: åˆ·æ–°é¡µé¢æˆ–é‡å¯æµè§ˆå™¨';
                }
                alert(errorMsg);
                
                // 3ç§’åç§»é™¤é”™è¯¯çŠ¶æ€
                setTimeout(() => {
                    if (!cameraActive) {
                        btn.classList.remove('error');
                        btn.title = 'ç‚¹å‡»å¯åŠ¨æ‘„åƒå¤´';
                    }
                }, 3000);
            }
        }

        // åˆ‡æ¢æ‘„åƒå¤´
        window.toggleCamera = async function() {
            const btn = document.getElementById('camera-btn');
            
            if (cameraActive && cameraInitialized) {
                // å·²è¿æ¥ï¼Œç‚¹å‡»å¯ä»¥é‡ç½®
                if (confirm('è¦é‡ç½®æ‘„åƒå¤´è¿æ¥å—ï¼Ÿ\n(å¦‚æœé‡åˆ°é—®é¢˜å¯ä»¥å°è¯•é‡ç½®)')) {
                    resetCamera();
                }
            } else {
                // æœªè¿æ¥ï¼Œå°è¯•åˆå§‹åŒ–
                await initCamera();
            }
        }

        // é¡µé¢å¸è½½æ—¶æ¸…ç†èµ„æº
        window.addEventListener('beforeunload', () => {
            stopCamera();
        });

    </script>
</body>
</html>